{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 let can1;\
let button;\
let hasStarted = false;\
const startTime = new Date().getTime();\
\
const tcycles = 12\
const stimSize = 64\
const actualsize = 1\
const rcycles = 14;\
const frequency = 15;\
const D = 10;\
const L = 20;\
var ctx1;\
\
let xylim = 2 * Math.PI * rcycles;\
let array = linspace(-xylim, xylim, 64);\
// let array = linspace(0,50,6);\
let testMeshGrid = meshgrid(array, array);\
\
let x1 = testMeshGrid[0];\
let y1 = testMeshGrid[1];\
\
let x1squared = x1.map(value => value.map(number => number**2));\
let y1squared = y1.map(value => value.map(number => number**2));\
\
let temp = addMatrices(x1squared, y1squared);\
let at = makeAtArray(x1, y1);\
\
let circle1 = temp.map(value => value.map(mapCircleOne));\
let circle2 = temp.map(value => value.map(mapCircleTwo));\
\
function setup() \{\
  ctx1 = createCanvas(400, 400, WEBGL);\
  background(220);\
  \
  button = createButton("Trial one");\
  button.position(125, 350);\
  button.mousePressed(changeStartState);\
  \
  noStroke()\
  ellipse(0,0,100,100);\
\}\
\
function changeStartState() \{\
  hasStarted = !hasStarted;\
\}\
\
function linspace(startValue, stopValue, sizeArray) \{\
  var linspaceArr = [];\
  var step = (stopValue - startValue) / (sizeArray - 1);\
  for (var i = 0; i < sizeArray; i++) \{\
    linspaceArr.push(startValue + (step * i));\
  \}\
  return linspaceArr;\
\}\
  \
function meshgrid(arrX, arrY)\{\
  const m = arrX.length;\
  const n = arrY.length;\
  let x1 = [];\
  let y1 = Array(m).fill().map(() => Array(n));\
\
  for(let i = 0; i < arrY.length; i++)\{\
    x1.push(arrX);\
  \}\
\
  for(let i = 0; i < arrY.length; i++)\{\
    for(let j = 0; j < arrX.length; j++)\{\
      y1[i][j] = arrY[i];\
    \}\
  \}\
\
  return [x1, y1];\
\}\
\
function mapCircleOne(num)\{\
  return (num <= xylim ** 2) ? 1 : 0\
\}\
\
function mapCircleTwo(num)\{\
  return (num >= 80) ? 1 : 0;\
\}\
\
function mapJsImage(num)\{\
  return (num < 0) ? 0 : 255; //doens't account for if the number is 0\
\}\
\
function makeAtArray(x1, y1)\{\
  const m = x1.length;\
  const n = y1.length;\
  let arctanArray = Array(m).fill().map(() => Array(n));\
  let i, j;\
\
    for (i = 0; i < x1.length; i++)\
      for (j = 0; j < y1.length; j++)\
        arctanArray[i][j] = Math.atan2(x1[i][j], y1[i][j]);\
  return arctanArray\
\}\
\
function addMatrices(m1, m2)\{\
  const m = m1.length;\
  const n = m2.length;\
  let tempArray = Array(m).fill().map(() => Array(n));\
  let i, j;\
    for (i = 0; i < m1.length; i++)\
      for (j = 0; j < m2.length; j++)\
        tempArray[i][j] = m1[i][j] + m2[i][j]\
  return tempArray\
\}\
\
function multiplyMatrices(m1, m2)\{\
  const m = m1.length;\
  const n = m2.length;\
  let tempArray = Array(m).fill().map(() => Array(n));\
  let i, j;\
    for (i = 0; i < m1.length; i++)\
      for (j = 0; j < m2.length; j++)\
        tempArray[i][j] = m1[i][j] * m2[i][j]\
  return tempArray\
\}\
\
function update_target_ssmvep_stim(frequency)\{\
  let currentTime = new Date().getTime();\
  t = currentTime - startTime;\
  \
  let phiAngle = (Math.PI / 2) + (Math.PI / 2) * Math.sin((2*Math.PI*t*(frequency/2)) - (Math.PI / 2));\
\
  let checksLHS = temp.map(value => value.map(number => Math.cos((Math.PI * Math.sqrt(number) / D) + phiAngle * (L / D))));\
  let checksRHS = at.map(value => value.map(number => Math.cos(number*tcycles)));\
  let tempChecks = multiplyMatrices(checksLHS, checksRHS);\
  let checks = tempChecks.map(value => value.map(number => Math.sign(number)));\
\
  //multiply 3 matrices together\
  let tempJsImage = multiplyMatrices(checks, circle1);\
  let jsImage = multiplyMatrices(tempJsImage, circle2);\
\
  //must have a predrawn white circle at 0,0\
  //appending to the array so that the colors are formed :/ \
  //first map the values -1, and 1 to be 0 or 255 \
  \
  jsReadyImage = jsImage.map(value => value.map(number => mapJsImage(number)));\
\
  let tempArray = new Uint8ClampedArray(40000)\
  let k = 0;\
  \
  for(let i = 0; i < jsReadyImage.length; i++)\{\
    for(let j = 0; j < jsReadyImage.length; j++)\{\
      tempArray[i][k] = jsReadyImage[i][j];\
      tempArray[i][k+1] = jsReadyImage[i][j];\
      tempArray[i][k+2] = jsReadyImage[i][j];\
      tempArray[i][k+3] = jsReadyImage[i][j];\
      \
      k+=4;\
    \}\
  \}\
  \
  let imageData = new ImageData(tempArray,100);\
  drawingContext.putImageData(imageData,100,100); //why is u broken \
\}\
\
function draw() \{\
  if (hasStarted) \{\
    update_target_ssmvep_stim(frequency);\
  \} \
\}}